/*8587 行编辑程序
时间限制:1000MS  内存限制:1000K
提交次数:3976 通过次数:1807

题型: 编程题   语言: C++;C



Description
*/
//利用栈编写简单的行编辑程序：接受用户从终端输入的程序或数据，在输入过程中，允许用户输入出差错，并在发现有误时可以及时更正。例如：当用户发现刚刚键入的一个字符是错的时，可以补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内差错较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。例如：假设从终端接受了这样两行字符： whli##ilr#e (s#*s) outcha@putchar(*s=#++); 则实际有效的是下列两行： while (*s) putchar(*s++); 本题目给出部分函数，要求将行编辑函数补充完整，并完成整个程序。
typedef char SElemType;
#include"malloc.h"
#include"stdio.h"
#include"math.h"
#include"stdlib.h" // exit()
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0A
typedef int Status; // Status是函数的类型,其值是函数结果状态代码，如OK等
#define STACK_INIT_SIZE 10 // 存储空间初始分配量
 #define STACKINCREMENT 2 // 存储空间分配增量
struct SqStack
{
 SElemType *base; // 在栈构造之前和销毁之后，base的值为NULL
 SElemType *top; // 栈顶指针
 int stacksize; // 当前已分配的存储空间，以元素为单位
}; // 顺序栈

Status InitStack(SqStack &S)       
{      
// 构造一个空栈S，该栈预定义大小为STACK_INIT_SIZE
// 请补全代码
  // if(S==NULL) return ERROR;
  S.base=(SElemType *)malloc(STACK_INIT_SIZE*sizeof(SElemType));
  if(S.base==NULL) return ERROR;
  S.top=S.base;
  S.stacksize=STACK_INIT_SIZE;
  return OK; 
}



Status DestroyStack(SqStack S)
{
  S.top=S.base;
  S.base=NULL;
  S.stacksize=0;
  free(S.base);
  return OK;
}
Status Push(SqStack &S,SElemType e)   
{

  if(S.base==NULL) return ERROR;
  //检查是否满栈
  if(S.top==&S.base[S.stacksize])
  {
    S.base=(SElemType *)realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(SElemType)); 
    if(S.base==NULL) return ERROR;
    S.stacksize+=STACKINCREMENT;
  }
  *S.top=e;
  S.top++;
  return OK;
    
}

Status Pop(SqStack &S,SElemType &e)   
{
// 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
// 请补全代码
  if(S.base==NULL) return ERROR;
  if(S.base==S.top) return ERROR;
  e=*(S.top-1);
  S.top--;
  return OK;
}

Status ClearStack(SqStack &S)
 { // 把S置为空栈
   S.top=S.base;
   return OK;
 }

Status GetTop(SqStack S,SElemType &e)   
{ 
// 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR
// 请补全代码
    if(S.base==NULL) return ERROR;
    if(S.base==S.top){/*printf("Empty Stack!\n"); */return ERROR;}
    e=*(S.top-1);
    return OK;
}

int StackLength(SqStack S) 
{
  // 返回栈S的元素个数
  // 请补全代码
    if(S.base==NULL) return ERROR;
    int n;
    if(S.top==S.base) return 0;
    else
    {
      for(n=0;S.top!=S.base;S.top--) n++;
      return n;
    }
} 

Status StackTraverse(SqStack S,Status(*visit)(SElemType))
 { // 从栈底到栈顶依次对栈中每个元素调用函数visit()。
   // 一旦visit()失败，则操作失败
   while(S.top>S.base)
     visit(*S.base++);
   printf("\n");
   return OK;
 }
Status visit(SElemType c)
 {
   printf("%c",c);
   return OK;
 }
 
 void LineEdit()
 { // 利用字符栈s，从终端接收一行并送至调用过程的数据区。算法3.2
   SqStack s;
   char ch,c;
   int n,i;
   InitStack(s);
   scanf("%d",&n);  //多case
   ch=getchar();
   for(i=1;i<=n;i++)
   { ch=getchar();
     while(ch!='\n')
    {
       switch(ch)
       {
         case '#':Pop(s,c);
                  break; // 仅当栈非空时退栈
         case '@':ClearStack(s);
                  break; // 重置s为空栈
         default :Push(s,ch); // 有效字符进栈
       }
       ch=getchar(); // 从终端接收下一个字符
     }
     StackTraverse(s,visit); // 将从栈底到栈顶的栈内字符输出
    ClearStack(s); // 重置s为空栈
    }
   DestroyStack(s);
 }
int main()
 {
     LineEdit();
     return 0;
 }



