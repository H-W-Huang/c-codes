// D  排序啊排序

// Time Limit:1000MS  Memory Limit:65535K
// 题型: 编程题   语言: 无限制
// 描述

// 这是一道短小精悍的题目。
//     给出n个不重复的数，例如{3，1，5}~我们可以把它们组成｛(3,3),(3,1),(3,5),(1,1),(1,3),

// (1,5),(5,5),(5,3),(5,1)｝
//     然后，就是排个序，我们定义(x1,y1)<(x2,y2)是满足x1<x2或者x1=x2,y1<y2；
//     也就是变成｛(1,1),(1,3),(1,5),(3,1),(3,3),(3,5),(5,1),(5,3),(5,5)｝
//     现在要你找出第k大的数对，例如当k=4的时候，答案就是（3，1）了~！！！

//     哎，我知道聪明的你，马上会发现n个不重复的数可以组成n^2对吧。

//     Accept it。加油。

// 输入格式

// 第一行输入case数，T
// 接下来2*T行，共T组数据
// 每组数据第一行是题目所描述的n,k（n,k均小于1000）
// 接下一行输入的是n个不重复的数。
// 输出格式

// 每个数据独立一行两个数格式为“a b”表示第k大的那一对数。
// 输入样例

// 2
// 3 4
// 3 1 5
// 5 1
// 1 2 3 4 5
// 输出样例

// 3 1
// 1 1
// Provider

// scau_acm
int a[10000];
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;


int sortAsort()
{
    int n,k,i;
    int k1,k2;  //对k进行处理得到的两个变量
    scanf("%d%d",&n,&k);
    k1=k/n;
    k2=k%n;
    // printf("k2===%d\n",k2);
    int a[n+2];
    for(i=0;i<n;i++) scanf("%d",&a[i]);
    sort(a,a+n);
    printf("%d,%d\n",a[k1],a[k2-1]);
}

int main()
{
    int t;
    scanf("%d",&t);
    while(t--) sortAsort();
    return 0;
}


/*******************
说明：
1.思路是这样的
    首先将输入的数递增排序 ( 注意数是不重复的 ) 得到 a数组
    列出的可以发先规律
    e.g n=4 k=6
    n=4是 从小到大如下所示 假设每一个pair为(n1,n2)
    (a,a) (b,a) (c,a) (d,a)
    (a,b) (b,b) (c,b) (d,b)
    (a,c) (b,c) (c,c) (d,c)
    (a,d) (b,d) (c,d) (d,d)
    每一列从小到排序，到达底端是，进入下一列
    由此可以进行定位。根据输入的n，k值来定位
    可以发现，(k/n) 得到的结果就是 n1在 a序列中的位置 (从0开始计数)
    而 (k%n-1) 即 n2在 a序列中的位置



********************/
