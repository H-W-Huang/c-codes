//问题要求可行解个数

/*************
在一个8*8的棋盘
限制：
皇后的 横向，总想，斜向（45度）上不可再放皇后
**************/


#include <cstdio>
int tot=0;  //可行解个数。作为全局变量，可以被函数直接使用。
int c[10000];
int n; //皇后个数
int cur=0;
//核心函数 search
// 求解是通过递归实现的
/************************

变量说明：
cur ：第cur行
c数组: 具体的，c[cur], 表示第cur列

*************************/


/****************************
此处需要来说明一下对角线的问题
以n==8为例:
下面为8×8的方阵
      0 1 2 3 4 5 6 7   c[cur] = x

0     # # # # # # # # 
1     # # # # # # # #  
2     # # # # # # # #    
3     # # # # # # # # 
4     # # # # # # # # 
5     # # # # # # # # 
6     # # # # # # # # 
7     # # # # # # # # 
8     # # # # # # # #  
cur=y

如果我们将x-y会得到什么呢？下面是结果：

       0  1  2  3  4  5  6  7    c[cur] = x
0      0  1  2  3  4  5  6  7  
1     -1  0  1  2  3  4  5  6   
2     -2 -1  0  1  2  3  4  5   
3     -3 -2 -1  0  1  2  3  4   
4     -4 -3 -2 -1  0  1  2  3   
5     -5 -4 -3 -2 -1  0  1  2   
6     -6 -5 -4 -3 -2 -1  0  1  
7     -7 -6 -5 -4 -3 -2 -1  0  
cur=y

可以得到各条主对角线，每条对角线对应一个值。这样只要判断当前皇后与 之前的皇后x-y的值是否相等即可判断是否在同一对角线上


****************************/


void search(int cur)
{
    //首先设置递归边界 cur最多就等于 n-1 ， 当cur等于n是，不再执行，且得到一个可行解（既然可以到达n了，所以会有解）
    // printf("cur ===%d\n",cur);
    if(cur==n) tot++; 
    else 
        {
            // printf("cur===%d\n",cur );
            for(int i=0;i<n;i++) // i表示列
            {
                int ok=1; //标志变量，作为接下来是否可以继续递归的标志，初始假定为1
                c[cur] = i;   //尝试将cur行的皇后放在i列
                for(int j=0;j<cur;j++)  // j 表示 cur之前的 0 ～ cur-1行的皇后
                    //核心判断
                    // 依次为 是否在同一列上？ 是否在同一主对角线上?　　是否在同一副对角线上？
                    if(c[cur]==c[j]||c[cur]-cur==c[j]-j||cur+c[cur]==j+c[j])
                        { ok=0; break; }//一旦与前边的有冲突，后面的也就不用在看了。此为剪枝 
                if(ok) search(cur+1); //如果之前的是没有冲突的话，对cur继续上边的过程 
                //注意这一句是单个递归调用的最后判断，不属于上个循环
            }
        }
}

int main()
{
    
    scanf("%d",&n);
    for(int i=0;i<n;i++) c[i]=i; //对c数组初始化
    search(cur);
    printf("%d\n", tot);
    return 0;
}