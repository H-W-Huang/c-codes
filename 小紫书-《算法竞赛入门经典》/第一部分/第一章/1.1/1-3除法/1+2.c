#include<stdio.h>
int main(){
    int a,b;
    //printf("请分别输入a和b:\n");
    //scanf("%d%d",&a,&b);
    //printf("%d\n",a+b);
    printf("%.2f\n", 8/3);
    printf("%.d\n", 8.0/3);
    printf("%.2f\n", 8.0/3.0);
    return 0;
}


//  说明：
//   以lf格式输出，但是参数为 8/3，这样的结果为0.0000
//   1431655765 ---->   (2^32-1)/（2^2-1)


// #include
// int main()
// {
//   float a = 12.5;
//   printf("%d\n", a);
//   printf("%d\n", (int)a);
//   printf("%d\n", *(int *)&a);
//   return 0;
// }

 

// 该项程序输出如下所示，
//  0
//  12
//  1095237632
// 原因是：浮点数是4个字节，12.5f 转成二进制是：01000001010010000000000000000000，十六进制是：0x41480000，十进制是：1095237632。所以，第二和第三个输出相信大家也知道是为什么了。而对于第一个，为什么会输出0，我们需要了解一下float和double的内存布局，如下：

// float: 1位符号位(s)、8位指数(e)，23位尾数(m,共32位)
// double: 1位符号位(s)、11位指数(e)，52位尾数(m,共64位)
// 然后，我们还需要了解一下printf由于类型不匹配，所以，会把float直接转成double，注意，12.5的float和double的内存二进制完全不一样。别忘了在x86芯片下使用是的反字节序，高位字节和低位字位要反过来。所以：

// float版：0x41480000 (在内存中是：00 00 48 41)
// double版：0x4029000000000000 (在内存中是：00 00 00 00 00 00 29 40)
// 而我们的%d要求是一个4字节的int，对于double的内存布局，我们可以看到前四个字节是00，所以输出自然是0了。 这个示例向我们说明printf并不是类型安全的，这就是为什么C++要引如cout的原因了。